## 一、数据库事务ACID
#### 事务(Transaction)

#### 事务的四大特性（ACID）：
##### 1.原子性（Atomicity）
一个事物内所有操作共同组成一个原子包，要么全部成功，要么全部失败。原子性保证了因为一些其他因素导致数据库异常，或者宕机。
##### 2.一致性（Consistency）
原子性只保证了一个事物内的所有操作同一性，大家同生死，不会出现你死了，我还活着。但是，原子性并没有保证大家同一时刻一起生，一起死。计算机指令是有先后顺序的，这样就决定了一个事物的提交，会经历一个时间过程，那么如果事物提交进行到了一半，我读取了数据库，会不会读到中间结果？

为了防止这样的情况，数据库事物的一致性就规定了事物提交前后，永远只可能存在事物提交前的状态和事物提交后的状态，从一个一致性的状态到另一个一致性状态，而不可能出现中间的过程态。也就是说事物的执行结果是量子化状态，而不是线性状态。

数据库提交事物会有一个过程，如果提交的时候，存在一个时间差，在提交的第一秒，一个删除过程还没完成到了第三秒才完成，会不会第一秒访问的人和第三秒访问的人得到不同的结果？出现不一致，状态的混沌？这就是一致性得保证的只会有前状态和后状态，绝不会出现中间态。



##### 3.隔离性（Isolation）
##### 4.持久性（Durability）
#### 事务的隔离级别：
##### 1.读未提交
##### 2.读已提交
##### 3.可重复读
读->写->读的过程，没有mvcc的情况下，；有mvcc的情况下
##### 4.串行化

#### 悲观锁：
描述的是一个流程，而不是特指某一种语言或某一种方法。
流程：加锁判断->做业务->释放锁->其他事务得到锁

#### 乐观锁：
一边做业务一边判断，结果直接反映出成功失败。如：update--业务--where version=?(做业务的过程与where判断的过程是不可分割的)。所以乐观锁需要得层的支持，而java/c#/php这类高级语言原生是不支持的，但是数据库支持。  
场景：两个人打开了两个窗口，都显示某个值是100,。现在两人同时操作加20的业务，要求只有其中一个成功，这里就要用到乐观锁。  
  
实际开发中遇上一个竞争性业务，首先上悲观锁，java层面部分代码用synchro包裹。这是万能方法，如果出现了集群，那么synchro改redis锁。如果出现了性能问题，那么再来考量此处业务能否适用乐观锁。如果能，改用乐观锁，如果不能，那么沿用悲观锁，性能问题用其他方法掩盖，但是一定要保证数据一致。  

以上为刚性事务（每个瞬间都是一致性的），又叫强一致型事务，而柔性事务是指可能捕捉到的一段时间内数据不一致，但最终数据是守恒一致的，这种称为柔性一致，又称为最终一致性。很多情况下没法保证刚性一致，刚性一致只能发生在单库事务中，而现实是分布式的。分布式事务中多为柔性事务。分布式事务分为两种：一种是考虑回滚的分布式事务（补偿型，具体有xa和tcc）,另一种是不考虑回滚的分布式事务（mq确保型）。第一种需要借助第三方框架比如LCN。

[转载自：https://www.jianshu.com/p/2a77146e70b4](https://www.jianshu.com/p/2a77146e70b4)
